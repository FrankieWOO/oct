<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ilqr</title>
  <meta name="keywords" content="ilqr">
  <meta name="description" content="Function for solving (finite horizon) optimal control problems with the Iterative Linear Quadratic Regulator method.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="#">ilqg</a> &gt; ilqr.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for .\ilqg&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>ilqr
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Function for solving (finite horizon) optimal control problems with the Iterative Linear Quadratic Regulator method.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [x, u, L, cost] = ilqr(f, j, dt, N, x0, u0, p ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Function for solving (finite horizon) optimal control problems with the Iterative Linear Quadratic Regulator method.

    [x, u, L, cost] = ilqr(f, j, dt, N, x0, u0, p )

 in:
     f  - dynamics function (function handle)
     j  - cost function (function handle)
     dt - time step
     N  - number of steps
     x0 - start state
     u0 - initial command sequence
     p  - parameter struct (optionally) containing:
      .lambda_init     - initial value of Levenberg-Marquardt lambda
      .lambda_factor   - factor for multiplying or dividing lambda
      .lambda_max      - threshold on lambda (exit if lambda exceeds this value)
      .iter_max        - threshold on number of iterations (exit if exceeded)
      .dcost_converge  - threshold on relative improvement in cost (exit if improvement less than this value)
      .online_printing - print: {0:never, 1:every iter, 2:final}
      .online_plotting - plot:  {0:never, 1:every iter, 2:final}
      .umax            - maximum command 
      .umin            - minimum command 
      .solver          - simulation solver
      (any fields that are unspecified will be set by default values).

 out:
     x      - predicted optimal state sequence
     u      - optimal feed-forward command sequence
     L      - optimal feedback gain sequence
     cost   - predicted cost

&gt; \author Matthew Howard (MH) matthew.howard@ed.ac.uk
&gt; \date 19/06/11 19:14:08</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../simulate/simulate_feedforward.html" class="code" title="function x = simulate_feedforward ( x0, f, u, p )">simulate_feedforward</a>	Simulate trajectory under open-loop, feed forward control, in continuous time</li><li><a href="../value/evaluate_trajectory_cost_fh.html" class="code" title="function cost = evaluate_trajectory_cost_fh ( x, u, l, p )">evaluate_trajectory_cost_fh</a>	Function for evaluating the cost along a trajectory under a given cost function</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../examples/test_ilqr_kawato_1dof_reach.html" class="code" title="">test_ilqr_kawato_1dof_reach</a>	Demo script: Test ilqr on reaching problem for 2-muscle, 1-joint system with 'kawato model' muscle dynamics.</li><li><a href="../examples/test_ilqr_kawato_arm.html" class="code" title="">test_ilqr_kawato_arm</a>	Demo script: Test ilqr on reaching problem for 6-muscle, 2-joint system with 'kawato model' muscle dynamics.</li><li><a href="../examples/test_ilqr_kawato_arm_reach.html" class="code" title="">test_ilqr_kawato_arm_reach</a>	Demo script: Test ilqr on reaching problem for 6-muscle, 2-joint system with 'kawato model' muscle dynamics.</li><li><a href="../examples/test_ilqr_lqr_fh.html" class="code" title="">test_ilqr_lqr_fh</a>	Demo script: Test solution of finite horizon linear-quadratic regulator problem in continuous time using ILQR.</li><li><a href="../examples/test_ilqr_maccepa_reach.html" class="code" title="">test_ilqr_maccepa_reach</a>	Demo script: Test ilqr on reaching problem for MACCEPA actuator.</li><li><a href="../maccepa/m-files/Test_ilqr_maccepa_contact_task.html" class="code" title="">Test_ilqr_maccepa_contact_task</a>	Demo script: Test ilqr on reaching problem for MACCEPA actuator.</li><li><a href="../maccepa/m-files/Test_ilqr_maccepa_contact_task.html" class="code" title="">Test_ilqr_maccepa_contact_task</a>	Demo script: Test ilqr on reaching problem for MACCEPA actuator.</li><li><a href="../optimize/test_ilqr_maccepa_reach.html" class="code" title="">test_ilqr_maccepa_reach</a>	Demo script: Test ilqr on reaching problem for MACCEPA actuator.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [l,L] = u_optimal(g, G, H, u, umin, umax, lambda)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Function for solving (finite horizon) optimal control problems with the Iterative Linear Quadratic Regulator method.</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%    [x, u, L, cost] = ilqr(f, j, dt, N, x0, u0, p )</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% in:</span>
0006 <span class="comment">%     f  - dynamics function (function handle)</span>
0007 <span class="comment">%     j  - cost function (function handle)</span>
0008 <span class="comment">%     dt - time step</span>
0009 <span class="comment">%     N  - number of steps</span>
0010 <span class="comment">%     x0 - start state</span>
0011 <span class="comment">%     u0 - initial command sequence</span>
0012 <span class="comment">%     p  - parameter struct (optionally) containing:</span>
0013 <span class="comment">%      .lambda_init     - initial value of Levenberg-Marquardt lambda</span>
0014 <span class="comment">%      .lambda_factor   - factor for multiplying or dividing lambda</span>
0015 <span class="comment">%      .lambda_max      - threshold on lambda (exit if lambda exceeds this value)</span>
0016 <span class="comment">%      .iter_max        - threshold on number of iterations (exit if exceeded)</span>
0017 <span class="comment">%      .dcost_converge  - threshold on relative improvement in cost (exit if improvement less than this value)</span>
0018 <span class="comment">%      .online_printing - print: {0:never, 1:every iter, 2:final}</span>
0019 <span class="comment">%      .online_plotting - plot:  {0:never, 1:every iter, 2:final}</span>
0020 <span class="comment">%      .umax            - maximum command</span>
0021 <span class="comment">%      .umin            - minimum command</span>
0022 <span class="comment">%      .solver          - simulation solver</span>
0023 <span class="comment">%      (any fields that are unspecified will be set by default values).</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% out:</span>
0026 <span class="comment">%     x      - predicted optimal state sequence</span>
0027 <span class="comment">%     u      - optimal feed-forward command sequence</span>
0028 <span class="comment">%     L      - optimal feedback gain sequence</span>
0029 <span class="comment">%     cost   - predicted cost</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%&gt; \author Matthew Howard (MH) matthew.howard@ed.ac.uk</span>
0032 <span class="comment">%&gt; \date 19/06/11 19:14:08</span>
0033 <span class="comment">%</span>
0034 <a name="_sub0" href="#_subfunctions" class="code">function [x, u, L, cost] = ilqr(f, j, dt, N, x0, u0, p )</a>
0035 
0036 <span class="comment">% unpack parameter struct</span>
0037 <span class="keyword">if</span> isfield(p,<span class="string">'lambda_init'</span>        ),lambda_init         = p.lambda_init        ;<span class="keyword">else</span>,lambda_init        = 1e-2    ;<span class="keyword">end</span>
0038 <span class="keyword">if</span> isfield(p,<span class="string">'lambda_factor'</span>      ),lambda_factor       = p.lambda_factor      ;<span class="keyword">else</span>,lambda_factor      = sqrt(10);<span class="keyword">end</span>
0039 <span class="keyword">if</span> isfield(p,<span class="string">'lambda_max'</span>         ),lambda_max          = p.lambda_max         ;<span class="keyword">else</span>,lambda_max         = 1e-2    ;<span class="keyword">end</span>
0040 <span class="keyword">if</span> isfield(p,<span class="string">'dcost_converge'</span>     ),dcost_converge      = p.dcost_converge     ;<span class="keyword">else</span>,dcost_converge     = 1e-9    ;<span class="keyword">end</span>
0041 <span class="keyword">if</span> isfield(p,<span class="string">'iter_max'</span>           ),iter_max            = p.iter_max           ;<span class="keyword">else</span>,iter_max           = 100     ;<span class="keyword">end</span>
0042 <span class="keyword">if</span> isfield(p,<span class="string">'online_printing'</span>    ),online_printing     = p.online_printing    ;<span class="keyword">else</span>,online_printing    = 1       ;<span class="keyword">end</span>
0043 <span class="keyword">if</span> isfield(p,<span class="string">'online_plotting'</span>    ),online_plotting     = p.online_plotting    ;<span class="keyword">else</span>,online_plotting    = 1       ;<span class="keyword">end</span>
0044 <span class="keyword">if</span> isfield(p,<span class="string">'umax'</span>               ),umax                = p.umax               ;<span class="keyword">else</span>,umax               = inf     ;<span class="keyword">end</span>
0045 <span class="keyword">if</span> isfield(p,<span class="string">'umin'</span>               ),umin                = p.umin               ;<span class="keyword">else</span>,umin               =-inf     ;<span class="keyword">end</span>
0046 <span class="keyword">if</span> isfield(p,<span class="string">'solver'</span>             ),solver              = p.solver             ;<span class="keyword">else</span>,solver             =<span class="string">'euler'</span>  ;<span class="keyword">end</span>
0047 
0048 <span class="comment">% initialise everything</span>
0049 dimX = size(x0, 1);   <span class="comment">% state dimensionality</span>
0050 dimU = size(u0, 1);   <span class="comment">% command dimensionality</span>
0051 ps=[];ps.dt=dt;ps.solver=solver; <span class="comment">% simulation parameters</span>
0052 
0053 <span class="keyword">if</span> size(u0,2)==1,                                   <span class="comment">% initial command sequence</span>
0054 u = repmat(u0,1,N-1);                               <span class="comment">% ...if one initial command given, use as full initial command sequence</span>
0055 <span class="keyword">else</span>,                                               <span class="comment">%</span>
0056 u    = u0;<span class="keyword">end</span>                                       <span class="comment">% ...if full command sequence given, use as initial command sequence</span>
0057 L    = zeros(dimU, dimX, N-1);                      <span class="comment">% initial feedback gain sequence</span>
0058 x    = <a href="../simulate/simulate_feedforward.html" class="code" title="function x = simulate_feedforward ( x0, f, u, p )">simulate_feedforward</a> ( x0, f, u, ps );       <span class="comment">% initial state sequence</span>
0059 cost = <a href="../value/evaluate_trajectory_cost_fh.html" class="code" title="function cost = evaluate_trajectory_cost_fh ( x, u, l, p )">evaluate_trajectory_cost_fh</a> ( x, u, j, ps ); <span class="comment">% initial cost</span>
0060 t    = (0:N-1)*dt;                                  <span class="comment">% time</span>
0061 
0062 <span class="comment">% initialise other matrices (for speed)</span>
0063 A  = zeros(dimX,dimX,N-1); 
0064 B  = zeros(dimX,dimU,N-1); 
0065 I  =   eye(dimX         );
0066 q0 = zeros(        1,N-1); 
0067 q  = zeros(     dimX,N-1); 
0068 Q  = zeros(dimX,dimX,N-1); 
0069 r  = zeros(     dimU,N-1); 
0070 R  = zeros(dimU,dimU,N-1); 
0071 P  = zeros(dimU,dimX,N-1); 
0072 s0 = zeros(        1,N  ); 
0073 s  = zeros(     dimX,N  ); 
0074 S  = zeros(dimX,dimX,N  ); 
0075 l  = zeros(     dimU,N-1); 
0076 
0077 <span class="comment">% initialise lambda</span>
0078 lambda = lambda_init;
0079 <span class="comment">% initialise update flag</span>
0080 update = 1;
0081 
0082 <span class="comment">% set up plotting</span>
0083 <span class="keyword">if</span> online_plotting
0084 online_plotting_fig=figure;clf,set(online_plotting_fig,<span class="string">'Name'</span>,<span class="string">'iLQR: Cost and Lambda Convergence'</span>),set(online_plotting_fig,<span class="string">'NumberTitle'</span>,<span class="string">'off'</span>)
0085 subplot(1,2,1),hold on,grid on,set(gca,<span class="string">'Yscale'</span>,<span class="string">'linear'</span>),title(<span class="string">'cost'</span>  ),ylabel(<span class="string">'cost'</span>  ),xlabel(<span class="string">'iteration'</span>)
0086 subplot(1,2,2),hold on,grid on,set(gca,<span class="string">'Yscale'</span>,<span class="string">'log'</span>)   ,title(<span class="string">'lambda'</span>),ylabel(<span class="string">'lambda'</span>),xlabel(<span class="string">'iteration'</span>)
0087 <span class="keyword">end</span>
0088 
0089 <span class="comment">% main loop</span>
0090 <span class="keyword">for</span> iter = 1:iter_max
0091     <span class="comment">%------ STEP 1: approximate dynamics and cost along new trajectory'</span>
0092     <span class="keyword">if</span> update,
0093         update = 0;
0094         <span class="comment">% compute LQ approximation</span>
0095         <span class="keyword">for</span> n = 1:N-1
0096             <span class="comment">% linearize dynamics, adjust for dt</span>
0097             [ff, f_x, f_u] = f(x(:,n), u(:,n));
0098             A(:,:,n) = I + dt*f_x;
0099             B(:,:,n) =     dt*f_u;
0100 
0101             <span class="comment">% quadratize cost, adjust for dt</span>
0102             [l0,l_x,l_xx,l_u,l_uu,l_ux] = j(x(:,n), u(:,n), t(n));
0103             q0(    n) = dt*l0;
0104             q (  :,n) = dt*l_x;
0105             Q (:,:,n) = dt*l_xx;
0106             r (  :,n) = dt*l_u;
0107             R (:,:,n) = dt*l_uu;
0108             P (:,:,n) = dt*l_ux;
0109         <span class="keyword">end</span>
0110 
0111         <span class="comment">% initialise value function approximation with final cost</span>
0112         [s0(N),s(:,N),S(:,:,N)] = j(x(:,N), nan, nan);
0113     <span class="keyword">end</span>
0114     
0115     <span class="comment">%------ STEP 2: compute optimal control law and cost-to-go</span>
0116     diverged=0;
0117     <span class="keyword">for</span> n = N-1:-1:1
0118         <span class="comment">% compute shortcuts g,G,H</span>
0119         g = r(  :,n) + B(:,:,n)'*s(  :,n+1); 
0120         G = P(:,:,n) + B(:,:,n)'*S(:,:,n+1)*A(:,:,n);
0121         H = R(:,:,n) + B(:,:,n)'*S(:,:,n+1)*B(:,:,n);
0122 
0123         <span class="comment">% check for divergence</span>
0124         <span class="keyword">if</span> any(~isfinite(H)), diverged=1; <span class="keyword">break</span>; <span class="keyword">end</span> <span class="comment">% divergence: EXIT</span>
0125 
0126         <span class="comment">% find control law</span>
0127         [l(:,n), L(:,:,n)] = <a href="#_sub1" class="code" title="subfunction [l,L] = u_optimal(g, G, H, u, umin, umax, lambda)">u_optimal</a>(g,G,H,u(:,n),umin,umax,lambda);
0128 
0129         <span class="comment">% update cost-to-go approximation</span>
0130         S (:,:,n) = Q (:,:,n) + A(:,:,n)'*S (:,:,n+1)*A(:,:,n) +    L(:,:,n)'*H*L(:,:,n) + L(:,:,n)'*G + G'*L(:,:,n);
0131         s (  :,n) = q (  :,n) + A(:,:,n)'*s (  :,n+1)          +    L(:,:,n)'*H*l(  :,n) + L(:,:,n)'*g + G'*l(:,n);
0132         s0(    n) = q0(    n) +           s0(    n+1)          + .5*l(  :,n)'*H*l(  :,n) + l(  :,n)'*g;
0133 
0134     <span class="keyword">end</span>
0135     <span class="keyword">if</span> diverged, fprintf(<span class="string">'Optimal control law and cost-to-go computation diverged. '</span>); <span class="keyword">break</span>; <span class="keyword">end</span><span class="comment">% divergence: EXIT</span>
0136 
0137     <span class="comment">%------ STEP 3A: new control sequence, trajectory, cost</span>
0138     <span class="comment">% simulate linearized system to compute new control</span>
0139     dx = zeros(dimX,1);
0140     <span class="keyword">for</span> n=1:N-1
0141         du = l(:,n) + L(:,:,n)*dx;   
0142         du = min(max(du+u(:,n),umin),umax) - u(:,n);
0143         dx = A(:,:,n)*dx + B(:,:,n)*du ;
0144         unew(:,n) = u(:,n) + du;
0145     <span class="keyword">end</span>
0146 
0147     <span class="comment">%------ STEP 3B: simulate system to compute new trajectory and cost</span>
0148     xnew    = <a href="../simulate/simulate_feedforward.html" class="code" title="function x = simulate_feedforward ( x0, f, u, p )">simulate_feedforward</a> ( x0, f, unew, ps );
0149     costnew = <a href="../value/evaluate_trajectory_cost_fh.html" class="code" title="function cost = evaluate_trajectory_cost_fh ( x, u, l, p )">evaluate_trajectory_cost_fh</a> ( xnew, unew, j, ps );<span class="comment">% initial cost</span>
0150 
0151     <span class="comment">%------ STEP 4: Levenberg-Marquardt method</span>
0152     <span class="keyword">if</span> costnew&lt;cost,
0153         <span class="comment">% decrease lambda (get closer to Newton method)</span>
0154         lambda = lambda / lambda_factor;
0155         dcost  = cost-costnew; <span class="comment">% decrease in cost</span>
0156         <span class="comment">% update x, u, cost</span>
0157         u    = unew;
0158         x    = xnew;
0159         cost = costnew;
0160         <span class="comment">% check for convergence</span>
0161         <span class="keyword">if</span> iter&gt;1 &amp;&amp; dcost&lt;dcost_converge,
0162             fprintf(<span class="string">'Cost improvement threshold reached. '</span>); <span class="keyword">break</span>; <span class="comment">% improvement too small: EXIT</span>
0163         <span class="keyword">end</span>
0164         <span class="comment">% flag update</span>
0165         update = 1;
0166     <span class="keyword">else</span>
0167         <span class="comment">% increase lambda (get closer to gradient descent)</span>
0168         lambda = lambda * lambda_factor;
0169         <span class="keyword">if</span> lambda&gt;lambda_max,
0170             fprintf(<span class="string">'Max. lambda reached. '</span>); <span class="keyword">break</span>; <span class="comment">% lambda too large: EXIT</span>
0171         <span class="keyword">end</span>
0172     <span class="keyword">end</span>
0173 
0174     <span class="comment">% plot/print stuff out</span>
0175     <span class="keyword">if</span> online_printing==1,fprintf(<span class="string">'Iteration = %d; Cost = %.4f; log(Lambda) = %.1f\n'</span>,iter,cost,log10(lambda));<span class="keyword">end</span>
0176     <span class="keyword">if</span> online_plotting==1,
0177         lambdas(iter)=lambda; costs(iter)=cost;
0178         set(0,<span class="string">'CurrentFigure'</span>,online_plotting_fig),
0179         subplot(1,2,1),plot([0:iter-1],costs);  
0180         subplot(1,2,2),plot([0:iter-1],lambdas);
0181     <span class="keyword">end</span>
0182 <span class="keyword">end</span>
0183 <span class="keyword">if</span> iter==iter_max
0184     fprintf(<span class="string">'Max. number of iterations reached. '</span>);
0185 <span class="keyword">end</span>
0186 <span class="comment">% print final result if necessary</span>
0187 <span class="keyword">if</span> online_printing==2,
0188     fprintf(<span class="string">'Iterations = %d;  Cost = %.4f'</span>, iter, cost);
0189 <span class="keyword">end</span>
0190 fprintf(<span class="string">'\n'</span>);
0191 <span class="comment">% close figure</span>
0192 <span class="keyword">if</span> online_plotting==1,close(online_plotting_fig),<span class="keyword">end</span>
0193 
0194 <span class="comment">% compute optimal control law</span>
0195 <a name="_sub1" href="#_subfunctions" class="code">function [l,L] = u_optimal(g, G, H, u, umin, umax, lambda)</a>
0196 
0197 <span class="comment">% eigenvalue decomposition, modify eigenvalues</span>
0198 [V,D] = eig(H);
0199 d = diag(D);
0200 d(d&lt;0) = 0;
0201 d = d + lambda;
0202 
0203 <span class="comment">% inverse modified Hessian, unconstrained control law</span>
0204 H1 = V*diag(1./d)*V';
0205 l = -H1*g;
0206 L = -H1*G;
0207 
0208 <span class="comment">% enforce constraints</span>
0209 l = min(max(l+u,umin),umax) - u;
0210 L((l+u==umin)|(l+u==umax),:) = 0;
0211</pre></div>
<hr><address>Generated on Thu 11-Feb-2016 17:34:06 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>